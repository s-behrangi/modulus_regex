<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>Modulus by Regex</title>
</head>
<body>
    <div class = "title">
        <h1>Calculate modulus with regular expressions</h1>
    </div>
    <div class = "the-meat">
        <div class = "description">
            <p>For any divisor <code>d</code>, remainder <code>r</code>, and base <code>b</code>, it's possible to generate a regular expression that matches exactly all <code>n</code> satisfying:</p> 
            <blockquote>n % d = r</blockquote>
            <p> when n is represented in the given base <code>b</code>. Note that for <code>r = 0</code>, this just tests whether <code>n</code> is divisible by <code>d</code>. There is no theoretical limit on <code>b</code>, but the implementation here only goes to hexadecimal to allow for the obvious encoding.</code></p>
            <p>The algorithm has exponential complexity and the resulting regex grows just as fast, rendering this method computationally intractable for divisors larger than ~30 or so, but I think the process is neat.</p>
            <p>You try:</p>  
        </div>
        <div class = "form">
            <div class = "warning-div">
                <code class = "size-warning" id = "size-warning"></code>
            </div>
            <br>
            <div class = "input-row">
                <div class = "fields">
                    <code>match n %</code> 
                    <input type="text" id="divisor" maxlength="2" value="7"> 
                    <code>=</code> 
                    <input type="text" id="remainder" maxlength="2" value="0">
                    <code>in base</code>
                    <input type="text" id="base" maxlength="2" value="2">
                </div>
                <div class = "buttons">
                    <button id="submit-btn"><b>Go</b></button>
                    <button id="copy-btn"><i class="fa fa-copy"></i></button>
                </div>
            </div>

            <div class = "constraints">
                <code class = "divisor-constraints"> d &gt; 0</code>
                <code class = "remainder-constraints">0 &le; r &lt; d</code>
                <code class = "base-constraints">1 &le; b &le; 16</code>
                
            </div>

            <div class = "output-row">
                <textarea type="text" id="output" wrap="hard"></textarea>
            </div>
            <div class = "empty-string-disclaimer">
                Note that the current implementation will also match the empty string (""). To change this, simply replace the trailing Kleene star * with +
            </div>
        </div>
        <script type="module" src="script.js"></script>
    <div class = "explanation">
        <h2> How does this work?</h2>
        
        <p>When I first saw <a href="https://www.codewars.com/kata/56a73d2194505c29f600002d">this</a> CodeWars problem I was at something of a loss. I couldn't fathom how a regular expression could be used to evaluate divisibility! It took a few hours of searching through assorted half-explanations before I grokked it—now I'm writing this for my own edification.</p>

        <h3>1) A numeral is a string evaluable by a DFA </h3>

        <p>Any given numeral representation of a number is a string, and therefore can be evaluated by a <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">Deterministic Finite Automaton</a> (DFA). In other words, the binary number "110" (6 in decimal) can be fed to a DFA one character at a time, from left-to-right, as the inputs "1", "1", and "0".</p>

        <h3>2) Each digit of a numeral has a deterministic effect on its remainder mod d </h3>

        <p>If the <code>i</code> digits we have read so far from the numeral <code>n</code> in base <code>b</code> representation have remainder <code>r<sub>i</sub></code> mod <code>d</code>, then upon reading the next digit <code>x</code>, the new running remainder will be:</p>

        <blockquote class = "equation">
            r<sub>i+1</sub> = b &times; r<sub>i</sub> + x mod d
        </blockquote>
        
        <p>This is guaranteed by the congruence relation of modular arithmetic, in that it is always true that <code>r &equiv; n mod d</code>. Importantly, this means that we don't need to store the <em>value</em> of the digits we have read so far; we only need to maintain a <em>state</em> representing the running remainder, and track transitions between states until we finish reading in the numeral.</p>
        
        <p>Meanwhile, <code>r<sub>0</sub> = 0</code>, because we haven't read anything in yet. Since we have both a base case and an <code>i + 1</code> case, we know that we can determine the remainder of any number by reading it one digit at a time and keeping track only of the running remainder.</p>

        <h3> 3) Therefore, we can produce a DFA that computes the remainder of a numeral</h3>

        <p>This DFA will have <code>d</code> states corresponding to each possible remainder in <code>[0..d)</code>, which we call <code>S<sub>i</sub></code>. Each state will have <code>b</code> directed edges indicating transitions to the next state depending on incoming digit; these transitions are calculated with the equation in part 2. Here is the DFA for divisor 3 in binary:</p>

        <img class = "diagram" src="./diagrams/dfa_three_plain.png">

        <p>Properly speaking, a DFA will be defined with a <em>starting</em> state and at least one <em>accepting</em> state, the latter indicated by a double-circle. The DFA accepts a string if it is in an accepting state after reading the string in. The starting state for our purposes will always be <code>0</code>. The accepting state can be whichever remainder we please. Here are two DFAs, one with accepting state <code>S<sub>0</sub></code> and the other <code>S<sub>1</sub></code>:</p>

        <img class = "diagram" src="./diagrams/dfa_three_pair.png">

        <p>In principle, each DFA can compute whether a given binary number satisfies the respective condition.</p>

        <h3>4) A DFA can be reduced to a regular expression</h3>

        <p>We use a process called <em>elimination</em>. Each state that is neither starting nor accepting is eliminated one at a time, with the incoming and outgoing transitions stitched together in the obvious way:</p>

        <img class = "diagram" src="./diagrams/elimination.png">

        <p>This might introduce parallel transitions, which we can merge with disjunction:</p>

        <img class = "diagram" src="./diagrams/parallel_merge.png">

        <p>Conventional DFA notation typically represents disjunction as addition (<code>+</code>), because it is a union operation, but because we're reducing to regex anyway I'm using the corresponding regex operator. Note that the above method applies to recursive transitions, i.e. transitions from a state to itself, just as well.</p>

        <p>Once we've eliminated the other states, our first DFA becomes:</p>

        <img class = "diagram" src="./diagrams/dfa_three_zero_reduced.png">
        
        <p>There is a slight abuse of notation here in that we are simplifying the role of incoming and outgoing arrows, which should be states of their own. For our purposes this simplification is inconsequential. What this reduced DFA tells us is that any string satisfying the given regular expression is a recursive transition from <code>r = 0</code> back to this state. Any other string will be rejected. Therefore, the regex we want allows arbitrarily many repetitions of this transition and nothing else:</p>

        <blockquote>
            <code>(0|1(0(1)*0)*1)*</code>
        </blockquote>

        <p>The case is slightly different if our target remainder isn't <code>0</code>, because we are left with separate starting and accepting states:</p>

        <img class = "diagram" src="./diagrams/dfa_three_one_reduced.png">

        <p>The reduction is simple, however. We can rewrite the situation thus:</p>

        <img class = "diagram" src="./diagrams/dfa_nonzero_remainder_reduced.png">

        <p>And our desired regular expression will be:</p>

        <blockquote>
            <code>(A|BD*C)*BD*</code>
        </blockquote>

        <p>Where <code>(A|B(D)*C)*</code> represents arbitrarily many returns to the starting state, before arriving at the accepting state with <code>B</code> and possibly looping with <code>(D)*</code>. In this case, the resulting regex is:</p>

        <blockquote>
            <code>(0|1(01*0)*1)*1(01*0)*</code>
        </blockquote>

        <p>When you run the above generator, it is simply executing this algorithm with the given parameters.</p>

        <h3>Note — there are two degenerate cases with trivial closed-form solutions:</h2>

        <p>a) if <code>d = b<sup>p</sup></code> for some integer <code>p</code>, then the matching expression for <code>r = 0</code> is:</p>

        <blockquote>
            <code>^*0{p}$</code>
        </blockquote>

        <p></b>and there is no solution for other <code>r</code>. For example, given divisor 4 in base 2, the expression <code>^*0{2}$</code> will match all binary numbers ending in <code>00</code>, i.e. multiples of 4.</p>

        <p>b) if <code>b = 1</code> then we are in a tally system, and the following will match the given parameters:</p>

        <blockquote>
            <code>^0{r}(0{d})*$</code>
        </blockquote>

        <h2> Implementation</h2>

        <p>The algorithm is written in Rust and packed for js with WebAssembly. You can check out the source <a href="https://github.com/s-behrangi/modulus_regex/">here</a>.</p>

        <h2>Notes</h2>

        <p>The first degenerate case above is unimplemented. It's fine.</p>

        <p>There is also currently no regex simplification implemented, so the resulting expressions may contain redundancies (including extraneous parentheses), especially as they grow larger. Unfortunately this will require a total refactor, and I'm not sure if I can make it work with WebAssembly. We'll see. </p>

        <h2 id = "bib">Bibliography</h2>
        
        <p><a href="https://s3.boskent.com/divisibility-regex/divisibility-regex.html">[1]</a> A similar generator, in JavaScript and computing only <code>r = 0</code></p>
        <p><a href="https://www.naukri.com/code360/library/dfa-to-regular-expression-conversion">[2]</a> A helpful illustration of DFA elimination</p>
        <p><a href="https://www.gatevidyalay.com/dfa-to-regular-expression-examples-automata/">[3]</a> Another such demonstration</p>
        <p><a href="https://stackoverflow.com/a/13223927">[4]</a> I liked this answer on StackOverflow</p>

    </div>
    </div>
</body>
</html>